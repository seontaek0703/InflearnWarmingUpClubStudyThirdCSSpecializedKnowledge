## 📖 그림으로 쉽게 배우는 자료구조와 알고리즘

### 🗓️ Day1(03 Mar, 2025) 개요: 운영체제 들어가기

✅ 자료구조 : 데이터가 어떤 구조로 저장되고 어떻게 사용되는지 나타내는 것

    자료구조마다 데이터에 대해 생성 입력 수정 삭제하는 처리 방법이 모두 상이함.

✅ 알고리즘 : 어떤 문제를 해결하기 위한 확실한 방법

    자료구조마다 알고리즘이 달라짐. 혹은 접근 방식에 따라 달라짐.

✅ 시간복잡도 : 특정 알고리즘이 어떤 문제를 해결하는 데 소요되는 시간

    일반적으로, 알고리즘의 성능은 이러한 '연산(처리) 속도'가 기준이 됨.

    연산속도가 느려지는 대표적인 이유는 '반복문(Loop)'

    시간 복잡도의 표기법
        * Big-Ω : 최선의 경우 (가장 적은 시도 횟수)
        * Big-O : 최악의 경우 (가장 많은 시도 횟수)
        * Big-Θ : 평균의 경우 (평균적인 시도 횟수)

| O(n!) | O(2ⁿ) | O(n²) | O(nlogn) | O(n) | O(logn) | O(1) |
|---|---|---|---|---|---|---|

계산량 ----------------------------------------------------------- 입력

    ex.  3n² + 2n + 100의 경우 O(n²) 표기법처럼 가장 큰 항에서 상수를를 탈락시켜 표기한다.

***** ***** ***** ***** *****

### 🗓️ Day2(04 Mar, 2025) 자료구조: 프로세스와 쓰레드

✅ 배열(Array): 모든 프로그래밍 언어에서 기본적으로 제공하는 '자료구조'

    배열은 선언 시 알려준 크기를 빈 메모리 공간에 연속적으로 할당하고 할당되지 않은 인덱스에 쓰레기 값을 추가적으로 넣으며 사용 시 1번 인덱스부터 참조하므로 읽기/쓰기, 즉 참조에서 좋은 성능을 보임. O(1)의 성능.

    단, 크기 예측이 힘들기에 메모리 낭비가 발생할 수 있어서 데이터 삽입/삭제의 성능은 좋지 않음.

✅ 연결리스트(Linked List): 데이터를 빈 메모리 공간에 분산하여 저장하는데 이런 공간 하나를 노드(Node)라고 표현함. 노드에는 데이터가 담긴 변수와 다음 노드를 가르키는 변수가 포함되어 있어 배열과 유사한 성격을 가지고 있음.

    연결리스트의 장점
    데이터 추가 시 빈 메모리 공간 아무데나 추가하기에 크기를 미리 알 필요가 없음.
    데이터를 삽입/삭제할 때 노드를 가리키는 방향만 바꿔주면 됨.

    연결리스트의 단점
    처음 인덱스만 알면되는 배열과 달리 연결리스트는 처음 노드부터 순차적으로 찾아나아가야해 참조 성능이 좋지 않음. O(n)의 성능.

✅ 추상 자료형: 어떠한 데이터와 그 데이터에 대한 연산을 표기하는 것.

    연결 리스트의 추상 자료형
    1. 모든 데이터 출력 printAll()
    2. 모든 데이터 제거 clear()
    3. 인덱스 삽입 insertAt(index, data);
    4. 마지막 삽입 insertLast(data);
    5. 인덱스 삭제 deleteAt(index);
    6. 마지막 삭제 deleteLast();
    7. 인덱스 읽기 getNodeAt(index);

***** ***** ***** ***** *****

### 🗓️ Day3(05 Mar, 2025) 자료구조: 프로세스와 쓰레드

✅ 스택(Stack): First In - Last Out(FILO)의 아주 단순한 규칙을 가진 리스트

    연결 리스트의 개념을 이용하여 삽입과 삭제 모두 리스트의 head index에서 진행하면 Stack 구조를 형성할 수 있음.

    에디터나 작업 툴에서 ctrl+z를 통해 가장 마지막 작업을 취소하는 경우.
    코드를 작성할 때 괄호 등의 문법 검사를 진행할 때. { ( ) }.

    스택의 추상 자료형
    1. 데이터 삽입              push
    2. 데이터 제거              pop
    3. 데이터 참조              peek
    4. 데이터 존재 여부 확인    isEmpty

✅ 큐(Queue): First In - First Out(FIFO)의 아주 단순한 규칙을 가진 리스트. 스택과 반대의 경향을 가짐.

    운영체제에서 CPU에게 프로세스 실행을 요청하면 요청한 순서대로 CPU가 처리함. FIFO 스케줄링.
    질서를 위해 서있는 줄.

    큐를 처리하기 위해 단방향 노드를 양방향 노드로. 즉, 이중연결리스트로 처리해야함.

    큐의 추상 자료형
    1. 데이터 삽입             enqueue
    2. 데이터 제거             dequeue
    3. 데이터 참조             front
    4. 데이터 존재 여부 확인    isEmpty

✅ 덱(Deque): 데이터의 삽입/삭제를 head와 tail에서 자유롭게 사용할 수 있음

    덱의 추상 자료형
    1. 모든 데이터 출력                printAll
    2. head에 데이터 삽입              addFirst
    3. head에서 데이터 제거            removeFirst
    4. tail에 데이터 삽입              addLast
    5. tail에서 데이터 제거            removeLast
    6. 리스트에 데이터 존재유무 확인    isEmpty

### 🗓️ Day4(06 Mar, 2025) 자료구조: CPU 스케줄링

✅ 해시 테이블(Hash Table): 언어마다 이릅이 다름. Hash, Map, HashMap, Dictionary 등

    해시 테이블의 장점: 빠른 데이터 읽기, 삽입, 삭제
    단점: 공간의 효율성이 좋지 않음(메모리를 많이 차지함) 따라서 좋은 해시 함수를 구현해야함.

    해시 테이블의 추상 자료형
    1. 데이터 삽입 set
    2. 데이터 읽기 get
    3. 데이터 제거 remove

### 🗓️ Day5(07 Mar, 2025) 자료구조: CPU 스케줄링

✅ 셋(Set): 데이터의 중복을 허용하지 않는 자료구조. 해시 테이블을 이용하오 구현함. 이러한 특징으로 Hash Set으로 불리기도 하지만 value는 사용하지 않고 key만 사용해서 구현함.

    셋의 추상 자료형
    1. 데이터 삽입          add(data);
    2. 데이터 체크          isContain(data);
    3. 데이터 제거          emove(data);
    4. 셋 비우기            clear();
    5. 셋 비었는지 체크      isEmpty();
    6. 모든 데이터 출력      printAll();

### 🗓️ Day6(10 Mar, 2025) 알고리즘: 프로세스 동기화화
### 🗓️ Day6(11 Mar, 2025) 알고리즘: 데드락
### 🗓️ Day6(12 Mar, 2025) 알고리즘: 데드락
### 🗓️ Day6(13 Mar, 2025) 알고리즘: 메모리
